Index: suricata-8.0.0/src/Makefile.am
===================================================================
--- suricata-8.0.0.orig/src/Makefile.am
+++ suricata-8.0.0/src/Makefile.am
@@ -389,6 +389,7 @@ noinst_HEADERS = \
 	output-json-email-common.h \
 	output-json-file.h \
 	output-json-flow.h \
+	output-json-flowstart.h \
 	output-json-frame.h \
 	output-json-ftp.h \
 	output-json-http.h \
@@ -987,6 +988,7 @@ libsuricata_c_a_SOURCES = \
 	output-json-email-common.c \
 	output-json-file.c \
 	output-json-flow.c \
+	output-json-flowstart.c \
 	output-json-frame.c \
 	output-json-ftp.c \
 	output-json-http.c \
Index: suricata-8.0.0/src/output-json-flow.c
===================================================================
--- suricata-8.0.0.orig/src/output-json-flow.c
+++ suricata-8.0.0/src/output-json-flow.c
@@ -53,7 +53,7 @@
 #include "flow-storage.h"
 #include "util-exception-policy.h"
 
-static SCJsonBuilder *CreateEveHeaderFromFlow(const Flow *f)
+SCJsonBuilder *CreateEveHeaderFromFlow(const Flow *f, const char *event_type)
 {
     char timebuf[64];
     char srcip[46] = {0}, dstip[46] = {0};
@@ -106,7 +106,11 @@ static SCJsonBuilder *CreateEveHeaderFro
         SCJbSetString(jb, "in_iface", f->livedev->dev);
     }
 
-    JB_SET_STRING(jb, "event_type", "flow");
+    if (event_type) {
+        SCJbSetString(jb, "event_type", event_type);
+    } else {
+        JB_SET_STRING(jb, "event_type", "flow");
+    }
 
     /* vlan */
     if (f->vlan_idx > 0) {
@@ -424,7 +428,7 @@ static int JsonFlowLogger(ThreadVars *tv
     /* reset */
     MemBufferReset(thread->buffer);
 
-    SCJsonBuilder *jb = CreateEveHeaderFromFlow(f);
+    SCJsonBuilder *jb = CreateEveHeaderFromFlow(f, NULL);
     if (unlikely(jb == NULL)) {
         SCReturnInt(TM_ECODE_OK);
     }
Index: suricata-8.0.0/src/output-json-flow.h
===================================================================
--- suricata-8.0.0.orig/src/output-json-flow.h
+++ suricata-8.0.0/src/output-json-flow.h
@@ -25,6 +25,7 @@
 #define SURICATA_OUTPUT_JSON_FLOW_H
 
 void JsonFlowLogRegister(void);
+SCJsonBuilder *CreateEveHeaderFromFlow(const Flow *f, const char *event_type);
 void EveAddFlow(Flow *f, SCJsonBuilder *js);
 void EveAddAppProto(Flow *f, SCJsonBuilder *js);
 
Index: suricata-8.0.0/src/output-json-flowstart.c
===================================================================
--- /dev/null
+++ suricata-8.0.0/src/output-json-flowstart.c
@@ -0,0 +1,301 @@
+/* Copyright (C) 2007-2017 Open Information Security Foundation
+ *
+ * You can copy, redistribute or modify this Program under the terms of
+ * the GNU General Public License version 2 as published by the Free
+ * Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * version 2 along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ */
+
+/**
+ * \file
+ *
+ * \author Martin Petracek <martin.petracek@nic.cz>
+ *
+ * JSON Flow start log module to log start of flows
+ *
+ */
+
+#include "suricata-common.h"
+#include "detect.h"
+#include "flow.h"
+#include "conf.h"
+
+#include "threads.h"
+#include "tm-threads.h"
+#include "threadvars.h"
+#include "util-debug.h"
+
+#include "decode-ipv4.h"
+#include "detect-parse.h"
+#include "detect-engine.h"
+#include "detect-engine-mpm.h"
+#include "detect-reference.h"
+
+#include "output.h"
+#include "output-json.h"
+#include "output-json-alert.h"
+#include "output-json-flow.h"
+#include "output-json-flowstart.h"
+
+#include "util-unittest.h"
+#include "util-unittest-helper.h"
+#include "util-classification-config.h"
+#include "util-privs.h"
+#include "util-print.h"
+#include "util-proto-name.h"
+#include "util-logopenfile.h"
+#include "util-time.h"
+#include "util-buffer.h"
+
+#include <net/if.h> /*if_indextoname*/
+
+#define MODULE_NAME "JsonFlowstartLog"
+
+#ifdef HAVE_LIBJANSSON
+
+typedef struct JsonFlowstartOutputCtx_ {
+    LogFileCtx *file_ctx;
+} JsonFlowstartOutputCtx;
+
+typedef struct JsonFlowstartLogThread_ {
+    JsonFlowstartOutputCtx *flowstart_ctx;
+    MemBuffer *buffer;
+} JsonFlowstartLogThread;
+
+/**
+ * \brief   Log the dropped packets in netfilter format when engine is running
+ *          in inline mode
+ *
+ * \param tv    Pointer the current thread variables
+ * \param p     Pointer the packet which is being logged
+ *
+ * \return return TM_ECODE_OK on success
+ */
+static int FlowstartLogJSON (ThreadVars *tv, JsonFlowstartLogThread *aft, const Packet *p)
+{
+    SCJsonBuilder *jb = CreateEveHeaderFromFlow(p->flow, "flow_start");
+    if (unlikely(jb == NULL))
+        return TM_ECODE_FAILED;
+
+    SCJbOpenObject(jb, "flow");
+    EveAddFlow(((Packet *)p)->flow, jb);
+    SCJbClose(jb);
+
+    MemBufferReset(aft->buffer);
+    OutputJsonThreadCtx out_ctx = {
+        .file_ctx = aft->flowstart_ctx->file_ctx,
+        .buffer = aft->buffer
+    };
+    OutputJsonBuilderBuffer(tv, p, p->flow, jb, &out_ctx);
+
+    SCJbFree(jb);
+
+    return TM_ECODE_OK;
+}
+
+#define OUTPUT_BUFFER_SIZE 65535
+static TmEcode JsonFlowstartLogThreadInit(ThreadVars *t, const void *initdata, void **data)
+{
+    JsonFlowstartLogThread *aft = SCMalloc(sizeof(JsonFlowstartLogThread));
+    if (unlikely(aft == NULL))
+        return TM_ECODE_FAILED;
+    memset(aft, 0, sizeof(*aft));
+
+    if(initdata == NULL)
+    {
+        SCLogDebug("Error getting context for EveLogDrop.  \"initdata\" argument NULL");
+        SCFree(aft);
+        return TM_ECODE_FAILED;
+    }
+
+    aft->buffer = MemBufferCreateNew(OUTPUT_BUFFER_SIZE);
+    if (aft->buffer == NULL) {
+        SCFree(aft);
+        return TM_ECODE_FAILED;
+    }
+
+    /** Use the Ouptut Context (file pointer and mutex) */
+    aft->flowstart_ctx = ((OutputCtx *)initdata)->data;
+
+    *data = (void *)aft;
+    return TM_ECODE_OK;
+}
+
+static TmEcode JsonFlowstartLogThreadDeinit(ThreadVars *t, void *data)
+{
+    JsonFlowstartLogThread *aft = (JsonFlowstartLogThread *)data;
+    if (aft == NULL) {
+        return TM_ECODE_OK;
+    }
+
+    MemBufferFree(aft->buffer);
+
+    /* clear memory */
+    memset(aft, 0, sizeof(*aft));
+
+    SCFree(aft);
+    return TM_ECODE_OK;
+}
+
+static void JsonFlowstartOutputCtxFree(JsonFlowstartOutputCtx *flowstart_ctx)
+{
+    if (flowstart_ctx != NULL) {
+        if (flowstart_ctx->file_ctx != NULL)
+            LogFileFreeCtx(flowstart_ctx->file_ctx);
+        SCFree(flowstart_ctx);
+    }
+}
+
+static void JsonFlowstartLogDeInitCtx(OutputCtx *output_ctx)
+{
+
+    JsonFlowstartOutputCtx *flowstart_ctx = output_ctx->data;
+    JsonFlowstartOutputCtxFree(flowstart_ctx);
+    SCFree(output_ctx);
+}
+
+static void JsonFlowstartLogDeInitCtxSub(OutputCtx *output_ctx)
+{
+
+    JsonFlowstartOutputCtx *flowstart_ctx = output_ctx->data;
+    SCFree(flowstart_ctx);
+    SCLogDebug("cleaning up sub output_ctx %p", output_ctx);
+    SCFree(output_ctx);
+}
+
+#define DEFAULT_LOG_FILENAME "flowstart.json"
+static OutputInitResult JsonFlowstartLogInitCtx(SCConfNode *conf)
+{
+    OutputInitResult ret = {NULL};
+    JsonFlowstartOutputCtx *flowstart_ctx = SCCalloc(1, sizeof(*flowstart_ctx));
+    if (flowstart_ctx == NULL)
+	// ok = 0
+        return ret;
+
+    flowstart_ctx->file_ctx = LogFileNewCtx();
+    if (flowstart_ctx->file_ctx == NULL) {
+        JsonFlowstartOutputCtxFree(flowstart_ctx);
+	// ok = 0
+        return ret;
+    }
+
+    if (SCConfLogOpenGeneric(conf, flowstart_ctx->file_ctx, DEFAULT_LOG_FILENAME, 1) < 0) {
+        JsonFlowstartOutputCtxFree(flowstart_ctx);
+	// ok = 0
+        return ret;
+    }
+
+    OutputCtx *output_ctx = SCCalloc(1, sizeof(OutputCtx));
+    if (unlikely(output_ctx == NULL)) {
+        JsonFlowstartOutputCtxFree(flowstart_ctx);
+	// ok = 0
+        return ret;
+    }
+
+    output_ctx->data = flowstart_ctx;
+    output_ctx->DeInit = JsonFlowstartLogDeInitCtx;
+
+    ret.ctx = output_ctx;
+    ret.ok = 1;
+    return ret;
+}
+
+static OutputInitResult JsonFlowstartLogInitCtxSub(SCConfNode *conf, OutputCtx *parent_ctx)
+{
+
+    OutputJsonCtx *ojc = parent_ctx->data;
+    OutputInitResult ret = {NULL};
+
+    JsonFlowstartOutputCtx *flowstart_ctx = SCCalloc(1, sizeof(*flowstart_ctx));
+    if (flowstart_ctx == NULL)
+	// ok = 0
+	return ret;
+
+    OutputCtx *output_ctx = SCCalloc(1, sizeof(OutputCtx));
+    if (unlikely(output_ctx == NULL)) {
+        JsonFlowstartOutputCtxFree(flowstart_ctx);
+	// ok = 0
+	return ret;
+    }
+
+    flowstart_ctx->file_ctx = ojc->file_ctx;
+
+    output_ctx->data = flowstart_ctx;
+    output_ctx->DeInit = JsonFlowstartLogDeInitCtxSub;
+    ret.ctx = output_ctx;
+    ret.ok = 1;
+    return ret;
+}
+
+/**
+ * \brief   Log the dropped packets when engine is running in inline mode
+ *
+ * \param tv    Pointer the current thread variables
+ * \param data  Pointer to the droplog struct
+ * \param p     Pointer the packet which is being logged
+ *
+ * \retval 0 on succes
+ */
+static int JsonFlowstartLogger(ThreadVars *tv, void *thread_data, const Packet *p)
+{
+    JsonFlowstartLogThread *td = thread_data;
+    int r = FlowstartLogJSON(tv, td, p);
+    if (r < 0)
+        return -1;
+    return 0;
+}
+
+
+/**
+ * \brief Check if we need to drop-log this packet
+ *
+ * \param tv    Pointer the current thread variables
+ * \param p     Pointer the packet which is tested
+ *
+ * \retval bool true or false
+ */
+static bool JsonFlowstartLogCondition(ThreadVars *tv, void *thread_data, const Packet *p)
+{
+    (void)thread_data;
+    if (PKT_IS_PSEUDOPKT(p)) return false;
+    if (!p->flow) return false;
+    if (p->l4.type == PACKET_L4_TCP) {
+        if ((p->flowflags & (FLOW_PKT_TOCLIENT_FIRST | FLOW_PKT_TOSERVER_FIRST)) != 0 &&
+           ((p->flow->flags & (FLOW_TO_DST_SEEN|FLOW_TO_SRC_SEEN)) == (FLOW_TO_DST_SEEN|FLOW_TO_SRC_SEEN))) return true;
+    }
+    else if ((p->flow->todstpktcnt + p->flow->tosrcpktcnt) == 1) return true;
+    return false;
+}
+
+void JsonFlowstartLogRegister (void)
+{
+    OutputPacketLoggerFunctions output_logger_functions = {
+        .LogFunc = JsonFlowstartLogger,
+        .FlushFunc = NULL,
+        .ConditionFunc = JsonFlowstartLogCondition,
+        .ThreadInitFunc = JsonFlowstartLogThreadInit,
+        .ThreadDeinitFunc = JsonFlowstartLogThreadDeinit,
+        .ThreadExitPrintStatsFunc = NULL,
+    };
+    OutputRegisterPacketModule(LOGGER_JSON_FLOWSTART, MODULE_NAME, "flow_start-json-log",
+            JsonFlowstartLogInitCtx, &output_logger_functions);
+    OutputRegisterPacketSubModule(LOGGER_JSON_FLOWSTART, "eve-log", MODULE_NAME,
+        "eve-log.flow_start", JsonFlowstartLogInitCtxSub, &output_logger_functions);
+}
+
+#else
+
+void JsonFlowstartLogRegister (void)
+{
+}
+
+#endif
Index: suricata-8.0.0/src/output-json-flowstart.h
===================================================================
--- /dev/null
+++ suricata-8.0.0/src/output-json-flowstart.h
@@ -0,0 +1,30 @@
+/* Copyright (C) 2007-2017 Open Information Security Foundation
+ *
+ * You can copy, redistribute or modify this Program under the terms of
+ * the GNU General Public License version 2 as published by the Free
+ * Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * version 2 along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ */
+
+/**
+ * \file
+ *
+ * \author Martin Petracek <martin.petracek@nic.cz>
+ *
+ */
+
+#ifndef __OUTPUT_JSON_FLOWSTART_H__
+#define __OUTPUT_JSON_FLOWSTART_H__
+
+void JsonFlowstartLogRegister(void);
+
+#endif /* __OUTPUT_JSON_FLOWSTART_H__ */
Index: suricata-8.0.0/src/output.c
===================================================================
--- suricata-8.0.0.orig/src/output.c
+++ suricata-8.0.0/src/output.c
@@ -48,6 +48,7 @@
 #include "output-json-alert.h"
 #include "output-json-anomaly.h"
 #include "output-json-flow.h"
+#include "output-json-flowstart.h"
 #include "output-json-netflow.h"
 #include "log-cf-common.h"
 #include "output-json-drop.h"
@@ -1146,6 +1147,8 @@ void OutputRegisterLoggers(void)
     JsonNetFlowLogRegister();
     /* json stats */
     JsonStatsLogRegister();
+    /* flowstart log */
+    JsonFlowstartLogRegister();
 
     /* DNP3. */
     JsonDNP3LogRegister();
Index: suricata-8.0.0/src/suricata-common.h
===================================================================
--- suricata-8.0.0.orig/src/suricata-common.h
+++ suricata-8.0.0/src/suricata-common.h
@@ -501,6 +501,7 @@ typedef enum LoggerId {
     LOGGER_JSON_FILE,
     LOGGER_TCP_DATA,
     LOGGER_JSON_FLOW,
+    LOGGER_JSON_FLOWSTART,
     LOGGER_JSON_NETFLOW,
     LOGGER_STATS,
     LOGGER_JSON_STATS,
