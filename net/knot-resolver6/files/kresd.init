#!/bin/sh /etc/rc.common

. /usr/share/libubox/jshn.sh
. /usr/share/resolver/functions.sh

START=61
STOP=00
USE_PROCD=1

# executables
KRES_EXEC=/usr/bin/knot-resolver
KRESCTL_EXEC=/usr/bin/kresctl

# tmpfs dirs
RUN_DIR=/var/run/knot-resolver
CACHE_DIR=/var/cache/knot-resolver

# config files, YAML is static, JSON is generated
CONFIG_FILE_YAML=/etc/knot-resolver/config.yaml
CONFIG_FILE_JSON=/var/run/knot-resolver/config.json

# variables
ROOTKEYFILE=/etc/root.keys

# Check the /etc/unbound/root.keys is reasonable and try to fix it with given command
check_root_key() {
    # Don't do anything if it looks OK
    grep -qE '[[:space:]](DNSKEY|DS|TYPE[[:digit:]][[:digit:]])[[:space:]]' $ROOTKEYFILE && return
    # Not OK -> run the command and hope for the best
    echo "Trying to restore broken $ROOTKEYFILE with command $@"
    eval "$@"
}

json_add_interface() {
    local interface="$1"
    local port="$2"
    [ "$interface" = "::0" ] && interface="::"
    json_add_object ""
    json_add_string interface "${interface}@${port}"
    json_add_string kind "dns"
    json_close_object
    json_add_object ""
    json_add_string interface "$interface@853"
    json_add_string kind "dot"
    json_close_object
}

json_add_network() {
    config_load resolver
    local section="common"

    json_add_object network

    local port
    config_get port "$section" port
    json_add_array listen
    config_list_foreach "$section" interface json_add_interface "$port"
    json_close_array

    local do_ipv4
    config_get_bool do_ipv4 "$section" net_ipv4
    json_add_boolean do-ipv4 $do_ipv4

    local do_ipv6
    config_get_bool do_ipv6 "$section" net_ipv6
    json_add_boolean do-ipv6 $do_ipv6

    local edns_buffer_size
    config_get edns_buffer_size "$section" edns_buffer_size 1232
    if [ "$edns_buffer_size" -ge 512 ]; then
        json_add_object edns-buffer-size
        json_add_string upstream "${edns_buffer_size}B"
        json_add_string downstream "${edns_buffer_size}B"
        json_close_object
    fi

    json_close_object
}

json_add_dnssec() {
    config_load resolver
    local section="common"

    local ignore_root_key
    config_get_bool ignore_root_key "$section" ignore_root_key 0
    if [ "$ignore_root_key" = "0" ]; then
        local keyfile
        config_get keyfile "$section" keyfile
        if [ -n "$keyfile" ]; then
            ROOTKEYFILE=$keyfile
            check_root_key cert-backup -x $ROOTKEYFILE
            json_add_object dnssec
            json_add_array trust-anchors-files
            json_add_object
            json_add_string file "$ROOTKEYFILE"
            json_add_boolean read-only 1
            json_close_object
            json_close_array
            json_close_object
        fi
    else
        json_add_object dnssec
        json_add_boolean enable 0
        json_close_object
        #FIXME: check this with forwarding, to be sure
    fi
}

json_add_addresses_file() {
    local file="$1"
    json_add_string "" "$file"
}

json_add_rpz() {
    local file="$1"
    json_add_object ""
    json_add_string file "$file"
    json_close_object
}

json_add_addresses() {
    local domain="$2"
    local section="$1"
    local ip name
    config_get ip "$section" ip
    config_get name "$section" name

    if [ -n "$name" ] && [ -n "$domain" ] && [ -n "$ip" ]; then
        json_add_string "$name.$domain" "$ip"
    fi
}

json_add_local_data() {
    config_load resolver
    local section="kresd"

    json_add_object local-data
    json_add_boolean nodata 1

    local static_domains
    config_get_bool static_domains common static_domains 1

    config_load dhcp
    if [ "$static_domains" = "1" ]; then
        local domain
        config_get domain dnsmasq local
        [ -z "$domain" ] || domain="`echo "$domain" | sed 's|/||g'`"

        local host_ip host_name
        config_get host_ip host ip
        config_get host_name host name

        local domain_ip domain_name
        config_get domain_ip domain ip
        config_get domain_name domain name

        if [ -n "$domain" ] && (([ -n "$host_ip" ] && [ -n "$host_name" ]) || ([ -n "$domain_ip" ] && [ -n "$domain_name" ])); then
            json_add_object addresses
            json_add_string "$host_name.$domain" "$host_ip"
            json_add_string "$domain_name.$domain" "$domain_ip"
            json_close_object
        fi
    fi
    config_load resolver

    local hostname_config
    config_get hostname_config "$section" hostname_config
    if [ -e "$hostname_config" ] && [ "$static_domains" = "1" ]; then
        json_add_array addresses-files
        config_list_foreach "$section" hostname_config json_add_addresses_file
        json_close_array
    fi

    local rpz_file
    config_get rpz_file "$section" rpz_file
    if [ -e "$rpz_file" ]; then
        json_add_array rpz
        config_list_foreach "$section" rpz_file json_add_rpz
        json_close_array
    fi

    json_close_object
}

json_add_forward_subtree() {
    local ip_list="$1"
    local enable_tls="$2"
    local port="$3"
    local pin_sha256="$4"
    local hostname="$5"
    local ca_files="$6"

    if [ -z "$ip_list" ]; then return; fi

    json_add_object
    json_add_string subtree "."
    json_add_array servers
    json_add_object

    for ip in $ip_list
    do
        json_add_array address
        #check nonstandard port 
        if [ "$port" == "853" ] || [ -z "$port" ]; then
            json_add_string "" "$ip"
        else
            json_add_string "" "$ip@$port"
        fi
        json_close_array
    done

    # check of DNS-over-TLS
    if [ "$enable_tls" == "1" ]; then
        json_add_string transport "tls"
        # prefer pin over hostname
        if [ ! -z "$pin_sha256" ]; then
            json_add_string pin-sha256 "$pin_sha256"
        elif [ ! -z "$hostname" ]; then
            json_add_string hostname "$hostname"
            if [ ! -z "$ca_file" ] && [ -f "$ca_file" ]; then
                json_add_string ca-file "$ca_file"
            fi
        fi
    fi
    json_close_object
    json_close_array
    json_close_object
}

json_add_forward() {
    config_load resolver
    local section="common"

    local forward_upstream forward_custom
    config_get_bool forward_upstream "$section" forward_upstream 1
    config_get forward_custom "$section" forward_custom

    json_add_array forward

    if [ -n "$forward_custom" ] && [ "$forward_upstream" = "1" ]; then
        dns_config_load "$forward_custom" json_add_forward_subtree
    elif [ "$forward_upstream" = "1" ] ; then
        # Test for resolv.conf.auto new location
        # https://github.com/openwrt/openwrt/commit/cd48d8d3420dd4df03daaa548227ceb487ba7104
        resolv_conf_path="$(ls -1 /tmp/resolv.conf.d/resolv.conf.vpn.* 2>/dev/null | head -n1)"
        if [ \! -f "$resolv_conf_path" ]; then
            if [ -f "/tmp/resolv.conf.d/resolv.conf.auto" ]; then
                resolv_conf_path="/tmp/resolv.conf.d/resolv.conf.auto"
            elif [ -f "/tmp/resolv.conf.auto" ]; then
                resolv_conf_path="/tmp/resolv.conf.auto"
            else
                resolv_conf_path=""
                echo "Error! File resolv.conf.auto is missing"
            fi
        fi

        local net_ipv4 net_ipv6
        config_get_bool net_ipv4 "$section" net_ipv4
        config_get_bool net_ipv6 "$section" net_ipv6

        local servers=$(get_servers_ip_addresses "$net_ipv4" "$net_ipv6" "$resolv_conf_path" 4)
        if [ -n "$servers" ]; then
            json_add_forward_subtree "$servers"
        fi
    fi

    json_close_array
}

json_add_cache() {
    config_load resolver
    local section="common"

    json_add_object cache

    local prefetch
    config_get_bool prefetch "$section" prefetch 0
    json_add_object prefetch
    json_add_boolean expiring $prefetch
    json_close_object

    json_close_object
}


json_add_logging() {
    config_load resolver
    local section="common"

    local verbose
    config_get verbose "$section" verbose 0
    if [ "$verbose" -ge 1 ]; then
        json_add_object logging
        json_add_string level "debug"
        json_close_object
    fi
}

json_add_lua() {
    config_load resolver
    local section="kresd"

    local include_config
    config_get lua_file_path "$section" include_config
    if [ -e "$include_config" ]; then
        json_add_object lua
        json_add_string script-file "$include_config"
        json_close_object
    else
        [ -z "$include_config" ] || echo "Warning! Knot Resolver custom Lua config file '$include_config' doesn't exist."
    fi
}

create_tmpfs_dirs() {
    mkdir -p "$RUN_DIR" "$CACHE_DIR"
}

create_json_config() {
    json_init
    json_add_network
    json_add_dnssec
    json_add_local_data
    json_add_forward
    json_add_cache
    json_add_logging
    json_add_lua
    json_close_object

    echo "$(json_dump -i)" > "$CONFIG_FILE_JSON"
}

start_knot_resolver() {
    config_load resolver
    local section="kresd"

    procd_open_instance

    # procd stdout/err logging
    local log_stderr log_stdout
    config_get_bool log_stderr "$section" log_stderr  1
    procd_set_param stderr "$log_stderr"
    config_get_bool log_stdout "$section" log_stdout  1
    procd_set_param stdout "$log_stdout"

    procd_set_param file /etc/config/resolver
    procd_set_param command $KRES_EXEC
    procd_append_param command --config $CONFIG_FILE_YAML $CONFIG_FILE_JSON
    procd_set_param respawn
    procd_close_instance
}

service_triggers() {
	procd_add_reload_trigger "dhcp"
}

start_service() {
    create_tmpfs_dirs
    create_json_config
    start_knot_resolver
}

reload_service() {
    create_json_config
    $KRESCTL_EXEC --config $CONFIG_FILE_YAML reload
}
